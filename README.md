# Лабораторная: B-Tree (Java, JMH)

## Описание
В проекте реализовано обобщённое B-дерево `BTree<K,V>` c параметром минимальной степени `t` (t ≥ 2), поддерживающее операции:
- вставка `(insert)`,
- поиск `(search)`,
- оценка высоты `(height)`,
- размер по числу уникальных ключей `(size)`.

Для оценки производительности используются бенчмарки JMH: замеряется среднее время поиска (попадание/промах) и вставки при разных параметрах степени дерева и предварительной загрузке данных.

## Структура проекта
```
src/main/java/org/example/
├─ BTree.java                     # Публичный интерфейс дерева
├─ BTreeImplementation.java       # Основная реализация B-дерева
├─ BTreeNode.java                 # Узел B-дерева
├─ BTreeInsertBenchmark.java      # JMH-бенчмарк на вставку
├─ BTreeSearchBenchmark.java      # JMH-бенчмарк на поиск (hit/miss)
├─ BenchmarkRunner.java           # точка входа для запуска всех бенчей
└─ Main.java                      # простая заглушка
```

## Классы и их роль

### `BTree<K extends Comparable<K>, V>`
Минимальный интерфейс дерева.
```java
Optional<V> search(K key);
void insert(K key, V value);
boolean delete(K key);   // TODO: не реализовано
int size();              // число уникальных ключей
int height();            // высота в уровнях, корень = 1
```

---

### `BTreeNode<K extends Comparable<K>, V>`
Внутренний контейнер узла B-дерева.
- Поля:
    - `boolean leaf` — признак листа,
    - `int t` — минимальная степень,
    - `List<K> keys`, `List<V> values` — отсортированные ключи и значения,
    - `List<BTreeNode<K,V>> children` — дочерние указатели (только для внутренних узлов).
- Утилиты:
    - `int keyCount()`,
    - `boolean isFull()` — `keys.size() == 2*t - 1`.

---

### `BTreeImplementation<K extends Comparable<K>, V>` — основная логика
Главная структура, реализующая интерфейс `BTree`.

Ключевые поля:
- `int t` — минимальная степень;
- `BTreeNode<K,V> root` — корень;
- `int size` — число уникальных ключей.

Основные методы:
- `Optional<V> search(K key)` — поиск значения по ключу.
- `void insert(K key, V value)` — вставка нового ключа/значения.
- `splitChild(...)` — классическая операция расщепления узла.
- `replaceIfExists(...)` — замена значения без увеличения размера.
- `int height()` — расчёт высоты дерева.
- `int size()` — количество уникальных ключей.

Сложности:
- Поиск: ~ `O(log N)`.
- Вставка: амортизированно `O(log N)`.

---

### `BTreeInsertBenchmark`
JMH-бенч на вставку.

Параметры:
- `@Param({"3", "8"}) int t` — минимальная степень;
- `@Param({"0", "10000"}) int preload` — размер предварительной загрузки.

---

### `BTreeSearchBenchmark`
JMH-бенч на поиск.

Параметры:
- `@Param({"10000","100000"}) int n` — размер датасета.

Бенчи:
- `searchHit()` — поиск существующего ключа;
- `searchMiss()` — поиск отсутствующего ключа.

---

### `BenchmarkRunner`
Запускает все классы с суффиксом `Benchmark` в пакете `org.example.BTree.*Benchmark`.

---

### `Main`
Заглушка `Hello world!`.

## Как собрать и запустить

```bash
./gradlew clean build
./gradlew run --args=''
```

Или запускать через IDE класс `BenchmarkRunner`.

## Проверяемые инварианты B-дерева
- В узле не более `2t-1` ключей.
- Внутренний узел с `k` ключами имеет `k+1` детей.
- Ключи внутри узла отсортированы.
- Все листья на одной глубине.
- Вставка поддерживает инварианты через `splitChild`.

## Идеи для экспериментов
- Сравнение разных `t`.
- Последовательные vs случайные ключи.
- Влияние `preload` на амортизацию вставок.
